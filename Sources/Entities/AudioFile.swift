// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import NaiveDate

public struct AudioFile: Codable {
    /// The index of the audio file.
    public var index: Int?
    /// The inode of the audio file.
    public var ino: String?
    public var metadata: FileMetadata?
    /// The time (in ms since POSIX epoch) when the audio file was added to the library.
    public var addedAt: Int?
    /// The time (in ms since POSIX epoch) when the audio file last updated. (Read Only)
    public var updatedAt: Int?
    /// The track number of the audio file as pulled from the file's metadata. Will be null if unknown.
    public var trackNumFromMeta: Int?
    /// The disc number of the audio file as pulled from the file's metadata. Will be null if unknown.
    public var discNumFromMeta: String?
    /// The track number of the audio file as determined from the file's name. Will be null if unknown.
    public var trackNumFromFilename: Int?
    /// The track number of the audio file as determined from the file's name. Will be null if unknown.
    public var discNumFromFilename: String?
    /// Whether the audio file has been manually verified by a user.
    public var isManuallyVerified: Bool?
    /// Whether the audio file is missing from the server.
    public var isInvalid: Bool?
    /// Whether the audio file has been marked for exclusion.
    public var exclude: Bool?
    /// Any error with the audio file. Will be null if there is none.
    public var error: String?
    /// The format of the audio file.
    public var format: String?
    /// The total length (in seconds) of the audio file.
    public var duration: Double?
    /// The bit rate (in bit/s) of the audio file.
    public var bitRate: Int?
    /// The language of the audio file.
    public var language: String?
    /// The codec of the audio file.
    public var codec: String?
    /// The time base of the audio file.
    public var timeBase: String?
    /// The number of channels the audio file has.
    public var channels: Int?
    /// The layout of the audio file's channels.
    public var channelLayout: String?
    /// If the audio file is part of an audiobook, the chapters the file contains.
    public var chapters: [BookChapter]?
    /// The type of embedded cover art in the audio file. Will be null if none exists.
    public var embeddedCoverArt: String?
    /// ID3 metadata tags pulled from the audio file on import. Only non-null tags will be returned in requests.
    public var metaTags: AudioMetaTags?
    /// The MIME type of the audio file.
    public var mimeType: String?

    public init(index: Int? = nil, ino: String? = nil, metadata: FileMetadata? = nil, addedAt: Int? = nil, updatedAt: Int? = nil, trackNumFromMeta: Int? = nil, discNumFromMeta: String? = nil, trackNumFromFilename: Int? = nil, discNumFromFilename: String? = nil, isManuallyVerified: Bool? = nil, isInvalid: Bool? = nil, exclude: Bool? = nil, error: String? = nil, format: String? = nil, duration: Double? = nil, bitRate: Int? = nil, language: String? = nil, codec: String? = nil, timeBase: String? = nil, channels: Int? = nil, channelLayout: String? = nil, chapters: [BookChapter]? = nil, embeddedCoverArt: String? = nil, metaTags: AudioMetaTags? = nil, mimeType: String? = nil) {
        self.index = index
        self.ino = ino
        self.metadata = metadata
        self.addedAt = addedAt
        self.updatedAt = updatedAt
        self.trackNumFromMeta = trackNumFromMeta
        self.discNumFromMeta = discNumFromMeta
        self.trackNumFromFilename = trackNumFromFilename
        self.discNumFromFilename = discNumFromFilename
        self.isManuallyVerified = isManuallyVerified
        self.isInvalid = isInvalid
        self.exclude = exclude
        self.error = error
        self.format = format
        self.duration = duration
        self.bitRate = bitRate
        self.language = language
        self.codec = codec
        self.timeBase = timeBase
        self.channels = channels
        self.channelLayout = channelLayout
        self.chapters = chapters
        self.embeddedCoverArt = embeddedCoverArt
        self.metaTags = metaTags
        self.mimeType = mimeType
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.index = try values.decodeIfPresent(Int.self, forKey: "index")
        self.ino = try values.decodeIfPresent(String.self, forKey: "ino")
        self.metadata = try values.decodeIfPresent(FileMetadata.self, forKey: "metadata")
        self.addedAt = try values.decodeIfPresent(Int.self, forKey: "addedAt")
        self.updatedAt = try values.decodeIfPresent(Int.self, forKey: "updatedAt")
        self.trackNumFromMeta = try values.decodeIfPresent(Int.self, forKey: "trackNumFromMeta")
        self.discNumFromMeta = try values.decodeIfPresent(String.self, forKey: "discNumFromMeta")
        self.trackNumFromFilename = try values.decodeIfPresent(Int.self, forKey: "trackNumFromFilename")
        self.discNumFromFilename = try values.decodeIfPresent(String.self, forKey: "discNumFromFilename")
        self.isManuallyVerified = try values.decodeIfPresent(Bool.self, forKey: "manuallyVerified")
        self.isInvalid = try values.decodeIfPresent(Bool.self, forKey: "invalid")
        self.exclude = try values.decodeIfPresent(Bool.self, forKey: "exclude")
        self.error = try values.decodeIfPresent(String.self, forKey: "error")
        self.format = try values.decodeIfPresent(String.self, forKey: "format")
        self.duration = try values.decodeIfPresent(Double.self, forKey: "duration")
        self.bitRate = try values.decodeIfPresent(Int.self, forKey: "bitRate")
        self.language = try values.decodeIfPresent(String.self, forKey: "language")
        self.codec = try values.decodeIfPresent(String.self, forKey: "codec")
        self.timeBase = try values.decodeIfPresent(String.self, forKey: "timeBase")
        self.channels = try values.decodeIfPresent(Int.self, forKey: "channels")
        self.channelLayout = try values.decodeIfPresent(String.self, forKey: "channelLayout")
        self.chapters = try values.decodeIfPresent([BookChapter].self, forKey: "chapters")
        self.embeddedCoverArt = try values.decodeIfPresent(String.self, forKey: "embeddedCoverArt")
        self.metaTags = try values.decodeIfPresent(AudioMetaTags.self, forKey: "metaTags")
        self.mimeType = try values.decodeIfPresent(String.self, forKey: "mimeType")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(index, forKey: "index")
        try values.encodeIfPresent(ino, forKey: "ino")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(addedAt, forKey: "addedAt")
        try values.encodeIfPresent(updatedAt, forKey: "updatedAt")
        try values.encodeIfPresent(trackNumFromMeta, forKey: "trackNumFromMeta")
        try values.encodeIfPresent(discNumFromMeta, forKey: "discNumFromMeta")
        try values.encodeIfPresent(trackNumFromFilename, forKey: "trackNumFromFilename")
        try values.encodeIfPresent(discNumFromFilename, forKey: "discNumFromFilename")
        try values.encodeIfPresent(isManuallyVerified, forKey: "manuallyVerified")
        try values.encodeIfPresent(isInvalid, forKey: "invalid")
        try values.encodeIfPresent(exclude, forKey: "exclude")
        try values.encodeIfPresent(error, forKey: "error")
        try values.encodeIfPresent(format, forKey: "format")
        try values.encodeIfPresent(duration, forKey: "duration")
        try values.encodeIfPresent(bitRate, forKey: "bitRate")
        try values.encodeIfPresent(language, forKey: "language")
        try values.encodeIfPresent(codec, forKey: "codec")
        try values.encodeIfPresent(timeBase, forKey: "timeBase")
        try values.encodeIfPresent(channels, forKey: "channels")
        try values.encodeIfPresent(channelLayout, forKey: "channelLayout")
        try values.encodeIfPresent(chapters, forKey: "chapters")
        try values.encodeIfPresent(embeddedCoverArt, forKey: "embeddedCoverArt")
        try values.encodeIfPresent(metaTags, forKey: "metaTags")
        try values.encodeIfPresent(mimeType, forKey: "mimeType")
    }
}
