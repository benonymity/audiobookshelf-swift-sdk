// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import NaiveDate

public struct MediaProgressWithMedia: Codable {
    /// The ID of the media progress. If the media progress is for a book, this will just be the libraryItemId. If for a podcast episode, it will be a hyphenated combination of the libraryItemId and episodeId.
    public var id: String?
    /// The ID of the library item the media progress is of.
    public var libraryItemID: String?
    /// The ID of the podcast episode the media progress is of. Will be null if the progress is for a book.
    public var episodeID: String?
    /// The total duration (in seconds) of the media. Will be 0 if the media was marked as finished without the user listening to it.
    public var duration: Double?
    /// The percentage completion progress of the media. Will be 1 if the media is finished.
    public var progress: Double?
    /// The current time (in seconds) of the user's progress. If the media has been marked as finished, this will be the time the user was at beforehand.
    public var currentTime: Double?
    /// Whether the media is finished.
    public var isFinished: Bool?
    /// Whether the media will be hidden from the "Continue Listening" shelf.
    public var isHideFromContinueListening: Bool?
    /// The time (in ms since POSIX epoch) when the media progress was last updated.
    public var lastUpdate: Int?
    /// The time (in ms since POSIX epoch) when the media progress was created.
    public var startedAt: Int?
    /// The time (in ms since POSIX epoch) when the media was finished. Will be null if the media has is not finished.
    public var finishedAt: String?
    /// The media of the library item the media progress is for.
    public var media: [String: Medium]?
    public var episode: PodcastEpisode?

    public enum Medium: Codable {
        case bookExpanded(BookExpanded)
        case podcastExpanded(PodcastExpanded)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(BookExpanded.self) {
                self = .bookExpanded(value)
            } else if let value = try? container.decode(PodcastExpanded.self) {
                self = .podcastExpanded(value)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Data could not be decoded as any of the expected types (BookExpanded, PodcastExpanded)."
                )
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .bookExpanded(let value): try container.encode(value)
            case .podcastExpanded(let value): try container.encode(value)
            }
        }
    }

    public init(id: String? = nil, libraryItemID: String? = nil, episodeID: String? = nil, duration: Double? = nil, progress: Double? = nil, currentTime: Double? = nil, isFinished: Bool? = nil, isHideFromContinueListening: Bool? = nil, lastUpdate: Int? = nil, startedAt: Int? = nil, finishedAt: String? = nil, media: [String: Medium]? = nil, episode: PodcastEpisode? = nil) {
        self.id = id
        self.libraryItemID = libraryItemID
        self.episodeID = episodeID
        self.duration = duration
        self.progress = progress
        self.currentTime = currentTime
        self.isFinished = isFinished
        self.isHideFromContinueListening = isHideFromContinueListening
        self.lastUpdate = lastUpdate
        self.startedAt = startedAt
        self.finishedAt = finishedAt
        self.media = media
        self.episode = episode
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.libraryItemID = try values.decodeIfPresent(String.self, forKey: "libraryItemId")
        self.episodeID = try values.decodeIfPresent(String.self, forKey: "episodeId")
        self.duration = try values.decodeIfPresent(Double.self, forKey: "duration")
        self.progress = try values.decodeIfPresent(Double.self, forKey: "progress")
        self.currentTime = try values.decodeIfPresent(Double.self, forKey: "currentTime")
        self.isFinished = try values.decodeIfPresent(Bool.self, forKey: "isFinished")
        self.isHideFromContinueListening = try values.decodeIfPresent(Bool.self, forKey: "hideFromContinueListening")
        self.lastUpdate = try values.decodeIfPresent(Int.self, forKey: "lastUpdate")
        self.startedAt = try values.decodeIfPresent(Int.self, forKey: "startedAt")
        self.finishedAt = try values.decodeIfPresent(String.self, forKey: "finishedAt")
        self.media = try values.decodeIfPresent([String: Medium].self, forKey: "media")
        self.episode = try values.decodeIfPresent(PodcastEpisode.self, forKey: "episode")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(libraryItemID, forKey: "libraryItemId")
        try values.encodeIfPresent(episodeID, forKey: "episodeId")
        try values.encodeIfPresent(duration, forKey: "duration")
        try values.encodeIfPresent(progress, forKey: "progress")
        try values.encodeIfPresent(currentTime, forKey: "currentTime")
        try values.encodeIfPresent(isFinished, forKey: "isFinished")
        try values.encodeIfPresent(isHideFromContinueListening, forKey: "hideFromContinueListening")
        try values.encodeIfPresent(lastUpdate, forKey: "lastUpdate")
        try values.encodeIfPresent(startedAt, forKey: "startedAt")
        try values.encodeIfPresent(finishedAt, forKey: "finishedAt")
        try values.encodeIfPresent(media, forKey: "media")
        try values.encodeIfPresent(episode, forKey: "episode")
    }
}
