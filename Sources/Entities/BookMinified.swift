// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import NaiveDate

public struct BookMinified: Codable {
    public var metadata: BookMetadataMinified?
    /// The absolute path on the server of the cover file. Will be null if there is no cover.
    public var coverPath: String?
    /// The book's tags.
    public var tags: [String]?
    /// The number of tracks the book's audio files have.
    public var numTracks: Int?
    /// The number of audio files the book has.
    public var numAudioFiles: Int?
    /// The number of chapters the book has.
    public var numChapters: Int?
    /// The total number of missing parts the book has.
    public var numMissingParts: Int?
    /// The number of invalid audio files the book has.
    public var numInvalidAudioFiles: Int?
    /// The total length (in seconds) of the book.
    public var duration: Double?
    /// The total size (in bytes) of the book.
    public var size: Int?
    /// The format of ebook of the book. Will be null if the book is an audiobook.
    public var ebookFormat: String?

    public init(metadata: BookMetadataMinified? = nil, coverPath: String? = nil, tags: [String]? = nil, numTracks: Int? = nil, numAudioFiles: Int? = nil, numChapters: Int? = nil, numMissingParts: Int? = nil, numInvalidAudioFiles: Int? = nil, duration: Double? = nil, size: Int? = nil, ebookFormat: String? = nil) {
        self.metadata = metadata
        self.coverPath = coverPath
        self.tags = tags
        self.numTracks = numTracks
        self.numAudioFiles = numAudioFiles
        self.numChapters = numChapters
        self.numMissingParts = numMissingParts
        self.numInvalidAudioFiles = numInvalidAudioFiles
        self.duration = duration
        self.size = size
        self.ebookFormat = ebookFormat
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.metadata = try values.decodeIfPresent(BookMetadataMinified.self, forKey: "metadata")
        self.coverPath = try values.decodeIfPresent(String.self, forKey: "coverPath")
        self.tags = try values.decodeIfPresent([String].self, forKey: "tags")
        self.numTracks = try values.decodeIfPresent(Int.self, forKey: "numTracks")
        self.numAudioFiles = try values.decodeIfPresent(Int.self, forKey: "numAudioFiles")
        self.numChapters = try values.decodeIfPresent(Int.self, forKey: "numChapters")
        self.numMissingParts = try values.decodeIfPresent(Int.self, forKey: "numMissingParts")
        self.numInvalidAudioFiles = try values.decodeIfPresent(Int.self, forKey: "numInvalidAudioFiles")
        self.duration = try values.decodeIfPresent(Double.self, forKey: "duration")
        self.size = try values.decodeIfPresent(Int.self, forKey: "size")
        self.ebookFormat = try values.decodeIfPresent(String.self, forKey: "ebookFormat")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(coverPath, forKey: "coverPath")
        try values.encodeIfPresent(tags, forKey: "tags")
        try values.encodeIfPresent(numTracks, forKey: "numTracks")
        try values.encodeIfPresent(numAudioFiles, forKey: "numAudioFiles")
        try values.encodeIfPresent(numChapters, forKey: "numChapters")
        try values.encodeIfPresent(numMissingParts, forKey: "numMissingParts")
        try values.encodeIfPresent(numInvalidAudioFiles, forKey: "numInvalidAudioFiles")
        try values.encodeIfPresent(duration, forKey: "duration")
        try values.encodeIfPresent(size, forKey: "size")
        try values.encodeIfPresent(ebookFormat, forKey: "ebookFormat")
    }
}
