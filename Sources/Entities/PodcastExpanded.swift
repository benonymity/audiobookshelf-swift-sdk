// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import NaiveDate

public struct PodcastExpanded: Codable {
    /// The ID of the library item that contains the podcast.
    public var libraryItemID: String?
    public var metadata: PodcastMetadataExpanded?
    /// The absolute path on the server of the cover file. Will be null if there is no cover.
    public var coverPath: String?
    /// The podcast's tags.
    public var tags: [String]?
    /// The downloaded episodes of the podcast.
    public var episodes: [PodcastEpisodeExpanded]?
    /// Whether the server will automatically download podcast episodes according to the schedule.
    public var isAutoDownloadEpisodes: Bool?
    /// The cron expression for when to automatically download podcast episodes. Will not exist if autoDownloadEpisodes is false.
    public var autoDownloadSchedule: String?
    /// The time (in ms since POSIX epoch) when the podcast was checked for new episodes.
    public var lastEpisodeCheck: Int?
    /// The maximum number of podcast episodes to keep when automatically downloading new episodes. Episodes beyond this limit will be deleted. If 0, all episodes will be kept.
    public var maxEpisodesToKeep: Int?
    /// The maximum number of podcast episodes to download when automatically downloading new episodes. If 0, all episodes will be downloaded.
    public var maxNewEpisodesToDownload: Int?
    /// The total size (in bytes) of the podcast.
    public var size: Int?

    public init(libraryItemID: String? = nil, metadata: PodcastMetadataExpanded? = nil, coverPath: String? = nil, tags: [String]? = nil, episodes: [PodcastEpisodeExpanded]? = nil, isAutoDownloadEpisodes: Bool? = nil, autoDownloadSchedule: String? = nil, lastEpisodeCheck: Int? = nil, maxEpisodesToKeep: Int? = nil, maxNewEpisodesToDownload: Int? = nil, size: Int? = nil) {
        self.libraryItemID = libraryItemID
        self.metadata = metadata
        self.coverPath = coverPath
        self.tags = tags
        self.episodes = episodes
        self.isAutoDownloadEpisodes = isAutoDownloadEpisodes
        self.autoDownloadSchedule = autoDownloadSchedule
        self.lastEpisodeCheck = lastEpisodeCheck
        self.maxEpisodesToKeep = maxEpisodesToKeep
        self.maxNewEpisodesToDownload = maxNewEpisodesToDownload
        self.size = size
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.libraryItemID = try values.decodeIfPresent(String.self, forKey: "libraryItemId")
        self.metadata = try values.decodeIfPresent(PodcastMetadataExpanded.self, forKey: "metadata")
        self.coverPath = try values.decodeIfPresent(String.self, forKey: "coverPath")
        self.tags = try values.decodeIfPresent([String].self, forKey: "tags")
        self.episodes = try values.decodeIfPresent([PodcastEpisodeExpanded].self, forKey: "episodes")
        self.isAutoDownloadEpisodes = try values.decodeIfPresent(Bool.self, forKey: "autoDownloadEpisodes")
        self.autoDownloadSchedule = try values.decodeIfPresent(String.self, forKey: "autoDownloadSchedule")
        self.lastEpisodeCheck = try values.decodeIfPresent(Int.self, forKey: "lastEpisodeCheck")
        self.maxEpisodesToKeep = try values.decodeIfPresent(Int.self, forKey: "maxEpisodesToKeep")
        self.maxNewEpisodesToDownload = try values.decodeIfPresent(Int.self, forKey: "maxNewEpisodesToDownload")
        self.size = try values.decodeIfPresent(Int.self, forKey: "size")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(libraryItemID, forKey: "libraryItemId")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(coverPath, forKey: "coverPath")
        try values.encodeIfPresent(tags, forKey: "tags")
        try values.encodeIfPresent(episodes, forKey: "episodes")
        try values.encodeIfPresent(isAutoDownloadEpisodes, forKey: "autoDownloadEpisodes")
        try values.encodeIfPresent(autoDownloadSchedule, forKey: "autoDownloadSchedule")
        try values.encodeIfPresent(lastEpisodeCheck, forKey: "lastEpisodeCheck")
        try values.encodeIfPresent(maxEpisodesToKeep, forKey: "maxEpisodesToKeep")
        try values.encodeIfPresent(maxNewEpisodesToDownload, forKey: "maxNewEpisodesToDownload")
        try values.encodeIfPresent(size, forKey: "size")
    }
}
