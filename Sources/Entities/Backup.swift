// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import NaiveDate

public struct Backup: Codable {
    /// The ID of the backup. Will be the date and time when the backup was created.
    public var id: String?
    /// Whether the backup includes library item covers and author images located in metadata.
    public var isBackupMetadataCovers: Bool?
    /// The backup directory path.
    public var backupDirPath: String?
    /// The date and time when the backup was created in a human-readable format.
    public var datePretty: String?
    /// The full path of the backup on the server.
    public var fullPath: String?
    /// The path of the backup relative to the metadata directory.
    public var path: String?
    /// The filename of the backup.
    public var filename: String?
    /// The size (in bytes) of the backup file.
    public var fileSize: Int?
    /// The time (in ms since POSIX epoch) when the backup was created.
    public var createdAt: Int?
    /// The version of the server when the backup was created.
    public var serverVersion: String?

    public init(id: String? = nil, isBackupMetadataCovers: Bool? = nil, backupDirPath: String? = nil, datePretty: String? = nil, fullPath: String? = nil, path: String? = nil, filename: String? = nil, fileSize: Int? = nil, createdAt: Int? = nil, serverVersion: String? = nil) {
        self.id = id
        self.isBackupMetadataCovers = isBackupMetadataCovers
        self.backupDirPath = backupDirPath
        self.datePretty = datePretty
        self.fullPath = fullPath
        self.path = path
        self.filename = filename
        self.fileSize = fileSize
        self.createdAt = createdAt
        self.serverVersion = serverVersion
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.isBackupMetadataCovers = try values.decodeIfPresent(Bool.self, forKey: "backupMetadataCovers")
        self.backupDirPath = try values.decodeIfPresent(String.self, forKey: "backupDirPath")
        self.datePretty = try values.decodeIfPresent(String.self, forKey: "datePretty")
        self.fullPath = try values.decodeIfPresent(String.self, forKey: "fullPath")
        self.path = try values.decodeIfPresent(String.self, forKey: "path")
        self.filename = try values.decodeIfPresent(String.self, forKey: "filename")
        self.fileSize = try values.decodeIfPresent(Int.self, forKey: "fileSize")
        self.createdAt = try values.decodeIfPresent(Int.self, forKey: "createdAt")
        self.serverVersion = try values.decodeIfPresent(String.self, forKey: "serverVersion")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(isBackupMetadataCovers, forKey: "backupMetadataCovers")
        try values.encodeIfPresent(backupDirPath, forKey: "backupDirPath")
        try values.encodeIfPresent(datePretty, forKey: "datePretty")
        try values.encodeIfPresent(fullPath, forKey: "fullPath")
        try values.encodeIfPresent(path, forKey: "path")
        try values.encodeIfPresent(filename, forKey: "filename")
        try values.encodeIfPresent(fileSize, forKey: "fileSize")
        try values.encodeIfPresent(createdAt, forKey: "createdAt")
        try values.encodeIfPresent(serverVersion, forKey: "serverVersion")
    }
}
